# Сервис валидации фотографий

**Автор:** Maxim Borzov

Специализированное веб-приложение для автоматической проверки цифровых фотографий на соответствие ряду критериев качества. В составе решения имеется API для загрузки изображений, их анализа согласно настраиваемым правилам и получения детальных результатов проверки.

Система применяет алгоритмы компьютерного зрения для оценки различных аспектов загруженных фотографий. Сюда входят технические параметры (размер файла, разрешение), анализ содержимого (обнаружение и позиционирование лица), а также метрики качества (резкость, освещение, однородность фона).

## Основные возможности

Сервис выполняет многоступенчатую проверку загруженных изображений по следующим направлениям:

| Категория проверки | Описание |
|---------------------|-------------|
| Параметры файла | Проверка формата изображения (JPEG, PNG, WebP, BMP, TIFF) и соответствия размера файла установленным ограничениям |
| Геометрия изображения | Проверка разрешения изображения на соответствие минимальным требованиям по ширине и высоте |
| Цветовые свойства | Проверка цветового режима для исключения монохромных изображений путем анализа каналов и насыщенности |
| Анализ содержимого | Поиск лиц и проверка наличия ровно одного лица в кадре |
| Позиционирование лица | Оценка положения и относительного размера лица в рамках кадра |
| Поза лица | Анализ ориентации лица для подтверждения фронтального положения (анфас) |
| Анализ фона | Проверка однородности фона и поиск нежелательных текстур, объектов или других людей |
| Обнаружение аксессуаров | Выявление таких видимых аксессуаров, как очки, головные уборы или руки вблизи лица |
| Качество изображения | Оценка технического качества, включая уровень резкости для исключения размытых фотографий |
| Эффект красных глаз | Обнаружение характерного эффекта «красных глаз», возникающего при использовании вспышки |
| Анализ освещения | Оценка качества освещения лица для выявления пересветов, недоэкспонированных участков и областей с низким контрастом |
| Проверка подлинности | Применение эвристик для различения реальных фотографий и компьютерной графики |

## Требования к системе

| Компонент | Требование | Назначение |
|-----------|-------------|---------|
| Система контейнеризации | Docker Engine | Запуск контейнеризованного приложения и базы данных |
| Оркестрация | Docker Compose (V2+) | Управление запуском и взаимодействием контейнеров |
| Интерпретатор Python | 3.9+ | Нужен только для локального запуска тестов |
| Оперативная память | Рекомендуется от 2 ГБ | Для работы веб-сервиса и моделей компьютерного зрения |
| Дисковое пространство | Рекомендуется от 1 ГБ | Для Docker-образа, логов, кэша и моделей |

## Установка и запуск

### Клонирование репозитория

Для начала необходимо получить исходный код проекта из системы контроля версий Git:

```bash
git clone https://github.com/borzov/photo-validation-service.git
cd photo-validation-service
```

### Запуск с помощью Docker Compose

Docker Compose автоматизирует процесс сборки, настройки и запуска всех компонентов сервиса:

```bash
docker-compose up -d
```

При выполнении этой команды Docker Compose осуществляет следующие операции:

1. Если Docker-образ для сервиса `app` еще не был собран локально, Docker Compose запустит процесс сборки согласно инструкциям в `Dockerfile`. Это может занять некоторое время при первом запуске, так как потребуется загрузка базового образа Python и установка всех зависимостей.

2. Docker Compose создаст изолированную сеть для взаимодействия контейнеров `app` и `db`.

3. Будет создан Docker-том с именем `postgres_data` (если он еще не существует) для постоянного хранения данных PostgreSQL.

4. Будут запущены следующие контейнеры:
   - `db`: Контейнер с базой данных PostgreSQL
   - `app`: Контейнер с приложением FastAPI (настроен на ожидание готовности PostgreSQL перед запуском)

5. Перед запуском веб-сервера Uvicorn, контейнер `app` выполнит команду `alembic upgrade head`, которая применит все необходимые миграции для создания или обновления схемы базы данных.

6. Uvicorn запустит приложение FastAPI, которое станет доступным на порту 8000 хост-машины (`http://localhost:8000`).

7. Флаг `-d` запускает контейнеры в отсоединенном (фоновом) режиме.

### Проверка статуса

После запуска можно проверить статус контейнеров с помощью команды:

```bash
docker-compose ps
```

Убедитесь, что оба сервиса (`app` и `db`) имеют статус `running` или `up`. Просмотреть логи можно с помощью команд `docker-compose logs app` или `docker-compose logs db`.

### Остановка сервиса

Для корректной остановки и удаления контейнеров, а также созданной сети:

```bash
docker-compose down
```

Важно учесть, что эта команда не удаляет Docker-том (`postgres_data`), поэтому данные базы данных сохраняются между перезапусками. Для полного удаления данных добавьте флаг `-v`: `docker-compose down -v`.

## Документация API

Сервис предоставляет REST API для взаимодействия.

### Эндпоинт загрузки (POST /api/v1/validate)

Данный эндпоинт инициирует процесс валидации путем загрузки файла изображения. Обработка выполняется асинхронно.

| Атрибут | Описание |
|-----------|-------------|
| HTTP метод | `POST` |
| Путь | `/api/v1/validate` |
| Заголовки | `Content-Type: multipart/form-data` |
| Тело запроса | Форм-данные с полем `file`, содержащим изображение в поддерживаемом формате (JPEG, PNG, WebP, BMP, TIFF) |

Пример запроса с использованием curl:
```bash
curl -X POST "http://localhost:8000/api/v1/validate" \
     -H "Content-Type: multipart/form-data" \
     -F "file=@/путь/к/вашей/фотографии.jpg;type=image/jpeg"

# Или для других форматов:
curl -X POST "http://localhost:8000/api/v1/validate" \
     -F "file=@/путь/к/вашей/фотографии.png;type=image/png"
```

Ответы:

1. Запрос принят (202 Accepted): Указывает на успешное принятие файла и постановку задачи в очередь обработки.
   ```json
   {
     "requestId": "ed8a1a4c-a8c8-4b3a-8c4e-7d3b1e9a2f0d"
   }
   ```
   Важно сохранить `requestId` для последующего получения результатов.

2. Некорректный запрос (400 Bad Request): Возвращается при ошибках валидации входных данных (неверный формат файла, превышение размера и т.д.).
   ```json
   {
     "detail": "Размер файла превышает лимит в 1024 КБ",
     "code": "FILE_TOO_LARGE"
   }
   ```

3. Ошибка сервера (500 Internal Server Error): Указывает на проблемы на стороне сервера во время обработки запроса (например, ошибки при сохранении файла).
   ```json
   {
     "detail": "Не удалось сохранить файл в хранилище"
   }
   ```

### Эндпоинт результатов (GET /api/v1/results/{requestId})

Позволяет получить текущий статус и результаты обработки задачи по её идентификатору.

| Атрибут | Описание |
|-----------|-------------|
| HTTP метод | `GET` |
| Путь | `/api/v1/results/{requestId}` |
| Параметр пути | `requestId` (строка): Уникальный идентификатор запроса |

Пример запроса с использованием curl:
```bash
curl -X GET "http://localhost:8000/api/v1/results/ed8a1a4c-a8c8-4b3a-8c4e-7d3b1e9a2f0d"
```

Ответы (200 OK): Структура ответа зависит от статуса обработки.

1. Статус `PENDING` (В очереди):
   ```json
   {
     "requestId": "ed8a1a4c-a8c8-4b3a-8c4e-7d3b1e9a2f0d",
     "status": "PENDING",
     "overallStatus": null, "processedAt": null, "processingTime": null,
     "checks": null, "issues": null, "errorMessage": null
   }
   ```

2. Статус `PROCESSING` (В обработке):
   ```json
   {
     "requestId": "ed8a1a4c-a8c8-4b3a-8c4e-7d3b1e9a2f0d",
     "status": "PROCESSING",
     "overallStatus": null, "processedAt": null, "processingTime": null,
     "checks": null, "issues": null, "errorMessage": null
   }
   ```

3. Статус `COMPLETED` (Обработка завершена):
   ```json
   // Пример: Одобренная фотография
   {
     "requestId": "ed8a1a4c-a8c8-4b3a-8c4e-7d3b1e9a2f0d",
     "status": "COMPLETED",
     "overallStatus": "APPROVED",
     "createdAt": "2025-05-04T14:10:05.500000",
     "processedAt": "2025-05-04T14:10:07.800000",
     "processingTime": 2.300,
     "checks": [
         // Все проверки PASSED
         { "check": "faceCount", "status": "PASSED", "reason": null, "details": { "count": 1, ... } }
     ],
     "issues": [],
     "errorMessage": null
   }

   // Пример: Отклоненная фотография
   {
     "requestId": "f0b9b5d1-b9d9-4c4b-9d5f-8e4c2f0b3e1e",
     "status": "COMPLETED",
     "overallStatus": "REJECTED",
     "createdAt": "2025-05-04T14:12:01.100000",
     "processedAt": "2025-05-04T14:12:03.200000",
     "processingTime": 2.100,
     "checks": [
         { "check": "faceCount", "status": "PASSED", ... },
         { "check": "blurriness", "status": "FAILED", "reason": "Face is blurry", "details": { "laplacian_variance": 35.2 } }
         // Другие проверки
     ],
     "issues": ["IMAGE_BLURRY"],
     "errorMessage": null
   }

   // Пример: Требуется ручная проверка
   {
     "requestId": "c2a8a4e3-a7e7-4b2b-8b3d-6f2a0f8b1d9c",
     "status": "COMPLETED",
     "overallStatus": "MANUAL_REVIEW",
     "createdAt": "2025-05-04T14:15:10.300000",
     "processedAt": "2025-05-04T14:15:12.900000",
     "processingTime": 2.600,
     "checks": [
         { "check": "accessories", "status": "NEEDS_REVIEW", "reason": "headwear detected", "details": { "accessories_list": ["headwear"] } },
         // Другие проверки PASSED или SKIPPED
     ],
     "issues": ["ACCESSORIES_HEADWEAR_DETECTED"],
     "errorMessage": null
   }
   ```

4. Статус `FAILED` (Ошибка обработки):
   ```json
   {
     "requestId": "b1c7c3f2-b6e6-4a1a-7a2c-5e1b9e7a0c8b",
     "status": "FAILED",
     "overallStatus": null, // или может содержать статус на момент ошибки
     "createdAt": "2025-05-04T14:18:05.000000",
     "processedAt": "2025-05-04T14:18:06.200000",
     "processingTime": 1.200,
     "checks": [ /* Результаты проверок до момента ошибки */ ],
     "issues": [ /* Проблемы, выявленные до ошибки */ ],
     "errorMessage": "CVProcessingError: Ошибка обработки изображения - недостаточно памяти"
   }
   ```

Ответы при ошибках:

1. Запрос не найден (404 Not Found):
   ```json
   { "detail": "Запрос не найден" }
   ```
2. Ошибка сервера (500 Internal Server Error):
   ```json
   { "detail": "Не удалось получить результаты валидации" }
   ```

## Архитектура статусов

Система использует двухуровневую архитектуру статусов:

### Статусы отдельных проверок (уровень модуля)
Каждая проверка может вернуть один из следующих статусов:
- **PASSED**: проверка пройдена успешно
- **FAILED**: проверка не пройдена, найдена критическая проблема
- **NEEDS_REVIEW**: проверка выявила проблему, требующую ручной оценки
- **SKIPPED**: проверка пропущена (например, не найдено лицо для проверок лица)

### Общий статус валидации (системный уровень)
На основе статусов всех проверок система определяет итоговый вердикт:
- **APPROVED**: все проверки прошли успешно (PASSED/SKIPPED)
- **REJECTED**: критическое количество проверок провалено (≥50% FAILED)
- **MANUAL_REVIEW**: требуется ручная проверка по одной из причин:
  - Есть проверки со статусом NEEDS_REVIEW
  - Небольшое количество провалов (<50% FAILED)

Эта архитектура обеспечивает гибкость: модули могут сигнализировать о неопределенных случаях через NEEDS_REVIEW, а система принимает окончательное решение на основе совокупности всех результатов.

## Описание полей ответа

| Поле | Тип | Описание |
|-------|------|-------------|
| `requestId` | строка | Уникальный идентификатор запроса |
| `status` | строка | Текущий статус обработки (`PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`) |
| `overallStatus` | строка \| null | Итоговый вердикт валидации (`APPROVED`, `REJECTED`, `MANUAL_REVIEW`). Устанавливается только при `status` равном `COMPLETED` |
| `createdAt` | строка | Временная метка создания запроса (ISO 8601 UTC) |
| `processedAt` | строка \| null | Временная метка завершения обработки (ISO 8601 UTC) |
| `processingTime` | число \| null | Время, затраченное на обработку изображения на сервере (в секундах) |
| `checks` | массив \| null | Массив объектов с результатами каждой выполненной проверки |
| `issues` | массив \| null | Список строковых идентификаторов проблем, обнаруженных во время проверок (обычно заполняется, когда `overallStatus` не равен `APPROVED`) |
| `errorMessage` | строка \| null | Текстовое описание ошибки, если `status` равен `FAILED` |

## Детали проверок

В таблице ниже представлена подробная информация о каждой проверке, выполняемой сервисом. Настройки пороговых значений и порядок выполнения определяются в файле `app/config/checks_config.yaml`.

| ID проверки | Описание требования | Алгоритм/Критерии | Возможные статусы | Пример деталей |
|----------|-------------------------|-------------------|-------------------|-----------------|
| `fileFormat` | Файл должен быть в поддерживаемом формате изображения | Проверка расширения файла (`.jpg`, `.jpeg`, `.png`, `.webp`, `.bmp`, `.tiff`) и MIME-типа | `PASSED`, `FAILED` | `"jpeg"` |
| `fileSize` | Размер файла не должен превышать лимит | Сравнение фактического размера файла с параметром `max_size_bytes` из конфигурации | `PASSED`, `FAILED` | `"512KB"` (PASSED) |
| `dimensions` | Размеры изображения должны быть не менее X×Y | Сравнение ширины и высоты с параметрами `min_width` и `min_height` | `PASSED`, `FAILED` | `"1200x1600px"` (PASSED) |
| `colorMode` | Изображение должно быть цветным | Проверка наличия 3 цветовых каналов. Дополнительно: анализ средней насыщенности в HSV (`> grayscale_saturation_threshold`) | `PASSED`, `FAILED` | `"Color"` (PASSED) |
| `realPhoto` | Изображение должно быть реальной фотографией | Комплексный анализ: градиенты (Sobel), текстура (Laplacian), гистограмма, энергия FFT, насыщенность. Сравнение метрик с порогами (`gradient_*`, `texture_*` и т.д.) | `PASSED`, `FAILED` | `{ "gradient_mean": 30.1, "texture_var_ratio": 0.6, ... }` |
| `faceCount` | На фото должно быть ровно одно лицо | Детекция лиц (YuNet/DNN/Haar), подсчет лиц с `confidence > face_confidence_threshold`. Сравнение с `min_count`/`max_count` (обычно 1) | `PASSED`, `FAILED` | `{ "count": 1, "required_min": 1, "required_max": 1, "face_confidences": [0.98] }` |
| `facePosition` | Лицо должно быть правильно расположено и кадрировано | Анализ bbox лица: `face_min/max_area_ratio`, `face_center_tolerance` (отклонение от центра), `min_margin_ratio` (отступы от краев), `min_width/height_ratio` | `PASSED`, `FAILED`, `SKIPPED` | `{ "face_bbox": [210,300,600,800], "face_area_ratio": 0.3, "center_offset_x_px": 5.0, ... }` |
| `facePose` | Лицо должно быть анфас | Оценка углов Yaw/Pitch/Roll по ориентирам с помощью `solvePnP`. Сравнение абсолютных значений с `max_yaw`/`max_pitch`/`max_roll` | `PASSED`, `FAILED`, `NEEDS_REVIEW`, `SKIPPED` | `{ "yaw": -3.5, "pitch": 1.2, "roll": -0.8, "thresholds": { ... } }` |
| `blurriness` | Изображение лица должно быть четким | Вычисление дисперсии Лапласиана для области лица. Сравнение с `laplacian_threshold` | `PASSED`, `FAILED`, `NEEDS_REVIEW`, `SKIPPED` | `{ "laplacian_variance": 210.5 }` |
| `redEye` | Отсутствие эффекта "красных глаз" | Поиск красных пикселей (`> red_threshold`, `> red_ratio_threshold` * G/B) в областях зрачков (через ориентиры). Проверка доли таких пикселей (`> min_red_pixel_ratio`) | `PASSED`, `FAILED`, `SKIPPED` | `{ "affected_eyes": [] }` (PASSED) |
| `background` | Фон должен быть однородным и светлым | Анализ области вне лица: `background_std_dev_threshold` (однородность), `grad_mean_threshold` / `edge_density_threshold` (текстуры), `is_dark_threshold` (яркость) | `PASSED`, `FAILED`, `NEEDS_REVIEW`, `SKIPPED` | `{ "background_mean": 180.0, "background_std_dev": 8.5, "gradient_mean": 5.2, ... }` |
| `extraneousObjects` | Отсутствие посторонних людей/объектов | Детекция людей (HOG) и крупных контуров (Canny, `min_object_contour_area_ratio`) на фоне | `PASSED`, `FAILED` (люди), `NEEDS_REVIEW` (объекты), `SKIPPED` | `{ "people_detected_bboxes": [], "large_contours_info": [] }` (PASSED) |
| `accessories` | Отсутствие неразрешенных аксессуаров | Детекция: очки (Haar), головные уборы (текстура лба), руки (цвет кожи по бокам), борода/усы (текстура подбородка) | `PASSED`, `NEEDS_REVIEW`, `SKIPPED` | `{ "accessories_list": [] }` (PASSED) |
| `lighting` | Правильное освещение лица | Анализ гистограммы яркости лица: `underexposure_threshold`, `overexposure_threshold`, `low_contrast_threshold`, `shadow/highlight_ratio_threshold` | `PASSED`, `FAILED`, `NEEDS_REVIEW`, `SKIPPED` | `{ "mean_brightness": 145.0, "std_dev_brightness": 60.0, "shadow_pixel_ratio": 0.02, ... }` |

## Тестирование

В комплект поставки входит скрипт для автоматизированного тестирования сервиса с набором изображений.

Использование:

1. Поместите тестовые изображения в любом поддерживаемом формате (JPEG, PNG, WebP, BMP, TIFF) в директорию `tests/photos/`.
2. Убедитесь, что сервис запущен и доступен.
3. Запустите скрипт:
   ```bash
   python tests/scripts/check_photos.py [параметры]
   ```

Скрипт последовательно отправляет все фотографии из указанной директории на валидацию, ожидает результаты (с повторными попытками) и формирует комплексный HTML-отчет в директории `tests/reports/`. Отчет включает превью изображений, итоговые статусы с подробными причинами и детали по каждой проверке. После завершения скрипт пытается открыть отчет в браузере по умолчанию.

Основные параметры командной строки:

| Параметр | Описание | Значение по умолчанию |
|-----------|-------------|---------------|
| `--api-url` | URL запущенного сервиса | `http://localhost:8000` |
| `--photo-dir` | Путь к директории с тестовыми фотографиями | `../photos` |
| `--report-dir` | Путь к директории для сохранения HTML-отчетов | `../reports` |
| `--max-attempts` | Максимальное количество попыток получения результата на один запрос | 30 |
| `--delay` | Задержка между попытками получения результата (секунды) | 1 |
| `--threads` | Количество параллельных потоков для обработки | 8 |

### Структура тестов

Тесты организованы в следующую структуру:

```
tests/
├── unit/                   # Модульные тесты
│   ├── conftest.py        # Конфигурация для unit-тестов
│   ├── test_api.py        # Тесты API эндпоинтов
│   └── test_cv_checks.py  # Тесты проверок компьютерного зрения
├── integration/           # Интеграционные тесты
│   ├── conftest.py        # Конфигурация для интеграционных тестов
│   └── test_integration.py # Комплексные тесты валидации
├── scripts/
│   └── check_photos.py    # Скрипт тестирования реальных фотографий
├── photos/                # Директория с тестовыми изображениями
└── reports/               # Генерируемые отчеты
```

Запуск тестов:

```bash
# Все тесты
make test

# Только unit-тесты
make test-unit

# Только интеграционные тесты  
make test-integration

# Тестирование реальных фотографий
make test-photos
```

## Разработка

### Зависимости

Основные библиотеки, используемые в проекте:

| Категория | Библиотеки | Назначение |
|----------|-----------|---------|
| Веб-фреймворк | FastAPI, Uvicorn | Веб-сервер и API-фреймворк |
| База данных | SQLAlchemy, Alembic, Psycopg2 | Взаимодействие с PostgreSQL и миграции |
| Компьютерное зрение | OpenCV (opencv-contrib-python), NumPy | Обработка изображений и алгоритмы компьютерного зрения |
| Конфигурация | PyYAML | Чтение конфигурационного файла |
| Работа с файлами | Python-multipart | Обработка загрузки файлов |

Полный список зависимостей находится в файле `requirements.txt`.

### Архитектура обработки

Сервис использует многоэтапный рабочий процесс:

1. Эндпоинт `POST /validate` принимает файл, выполняет начальные проверки (формат, размер), сохраняет его в локальное хранилище (`app/storage`) и создает запись в базе данных (`app/db`) со статусом `PENDING`.

2. Идентификатор запроса и путь к файлу помещаются в асинхронную очередь (`asyncio.Queue` в `app/worker/tasks.py`).

3. Фоновый процесс (`start_worker`) извлекает задачи из очереди.

4. Для каждой задачи рабочий процесс:
   - Обновляет статус запроса в базе данных на `PROCESSING`
   - Считывает файл изображения
   - Декодирует изображение с помощью OpenCV
   - Запускает последовательность проверок через `CheckRunner` (`app/cv/checks/runner.py`)
   - `CheckRunner` использует `CheckRegistry` (`app/cv/checks/registry.py`) для получения экземпляров требуемых проверок и их конфигурации из `app/config/checks_config.yaml`
   - Каждая проверка (`app/cv/checks/*/*.py`) выполняет свой анализ и возвращает результат
   - Управляет параллельностью с помощью семафора (`app/core/concurrency.py`)

5. После выполнения всех проверок (или при возникновении ошибки) рабочий процесс обновляет запись в базе данных итоговым статусом (`COMPLETED` или `FAILED`), результатами проверок (`checks`), списком проблем (`issues`), временем обработки (`processingTime`) и/или сообщением об ошибке (`errorMessage`).

6. Временный файл изображения удаляется из хранилища.

7. Эндпоинт `GET /results/{requestId}` запрашивает данные из базы данных по идентификатору и возвращает их клиенту.

### Конфигурация проверок (app/config/checks_config.yaml)

Этот файл является центральным местом для настройки поведения валидатора. С его помощью можно:

- Включать/отключать отдельные проверки (`enabled: true/false`)
- Определять порядок выполнения проверок (`check_order`)
- Задавать специфические параметры и пороги для каждой проверки (раздел `checks.<check_id>.params`)
- Настраивать системное поведение, например, прерывать ли цепочку проверок после первой неудачи (`system.stop_on_failure`)

При добавлении нового класса проверки в `app/cv/checks` он будет автоматически зарегистрирован и, если отсутствует в `checks_config.yaml`, добавлен туда с параметрами по умолчанию при следующем запуске сервиса.

### Добавление новых проверок

1. Создайте новый Python-файл в соответствующей поддиректории `app/cv/checks/` (например, `app/cv/checks/quality/new_check.py`

## Устранение неполадок

Распространенные проблемы и их решения:

| Проблема | Возможные решения |
|-------|-------------------|
| Сервис не запускается / Ошибки Docker Compose | - Убедитесь, что Docker и Docker Compose установлены и запущены<br>- Проверьте, что порты 8000 и 5432 не заняты другими приложениями<br>- Изучите логи контейнеров (`docker-compose logs app` и `docker-compose logs db`) |
| Ошибки подключения к базе данных при миграции или запуске | - Убедитесь, что контейнер `db` (PostgreSQL) успел запуститься до `app`. Docker Compose настроен на ожидание, но в редких случаях могут возникать проблемы<br>- Проверьте переменную окружения `DATABASE_URL` в `docker-compose.yml` |
| Ошибки загрузки моделей (FileNotFoundError, Download Error) | - Убедитесь, что контейнер `app` имеет доступ к интернету для загрузки моделей, если они отсутствуют локально<br>- Проверьте права доступа к директории `models/`, если вы монтируете ее вручную |
| Ошибка `Failed to decode image` | - Загруженный файл поврежден или не является корректным изображением<br>- Убедитесь, что файл в поддерживаемом формате (JPEG, PNG, WebP, BMP, TIFF) |
| Ошибка "Не удалось получить результат валидации" (исправлено в v2.1) | - Обновитесь до версии 2.1+<br>- Проверьте доступность health endpoint (`/health`)<br>- Увеличьте таймауты в тестовом скрипте |
| OpenCV "releaseReference" ошибки (исправлено в v2.1) | - Обновитесь до версии 2.1+ - проблематичные DNN модели были заменены<br>- При использовании собственных моделей проверьте их совместимость |
| Тесты не запускаются | - Используйте `make test` или `pytest tests/unit/` и `pytest tests/integration/`<br>- Проверьте виртуальное окружение и установленные зависимости<br>- Убедитесь, что тестовая база данных доступна |

## История версий

### Версия 2.2 - 23-05-2025

- Реализована централизованная система управления конфигурацией с Pydantic-схемами, hot-reload и системой резервного копирования.
- Добавлены REST API эндпоинты для CRUD операций с конфигурацией, включая валидацию, экспорт/импорт и управление секциями.
- Создан веб-интерфейс администратора с адаптивным дизайном, формами, валидацией в реальном времени и автоматическим обнаружением проверок.
- Интегрирована новая система конфигурации в основной API с монтированием админ-панели и обновленным мониторингом.
- Обновлена архитектура проверок компьютерного зрения с улучшенной регистрацией модулей и исполнителем задач.
- Добавлены новые модули проверки качества изображений и расширены возможности анализа фона и лица.
- Созданы руководства по архитектуре, план управления конфигурацией и документация по переводу.
- Обновлена инфраструктура тестирования с новыми скриптами и улучшенной конфигурацией.

### Версия 2.1 - 02-01-2025

- Исправлена ошибка "Не удалось получить результат валидации" через обновление health check и увеличение таймаутов с 6 до 30 секунд.
- Решена проблема OpenCV DNN "releaseReference" путем переработки детектора лиц без проблематичных DNN моделей.
- Добавлена поддержка дополнительных форматов изображений: PNG, WebP, BMP, TIFF с безопасной валидацией MIME-типов.
- Улучшено отображение причин отклонения фотографий через поля `reason` и массив `issues` в HTML-отчетах.
- Реорганизована структура тестов на `tests/unit/` и `tests/integration/` с отдельными конфигурациями.
- Добавлена многопоточная обработка в тестовый скрипт с настраиваемым количеством потоков.
- Унифицирован язык документации и комментариев кода на английский с соблюдением PEP 257.
- Обновлены GitHub Actions workflows с раздельными этапами для unit и integration тестов.
- Добавлен Makefile с автоматизированными командами для тестирования и развертывания.
- Реализована поддержка SQLite для тестирования и PostgreSQL для продакшена в одной кодовой базе.

### Версия 2.0 - 03-05-2025

- Переход на полностью асинхронную обработку запросов с использованием `asyncio.Queue`. Реализована модульная система проверок (`app/cv/checks`) с реестром и исполнителем.
- Параметры и порядок проверок вынесены во внешний YAML-файл (`app/config/checks_config.yaml`).
- Интегрированы улучшенные модели (YuNet, DNN, LBF Facemark) для обнаружения лиц и ориентиров. Добавлены/усовершенствованы алгоритмы проверок (реалистичность, фон, аксессуары, освещение и др.). Реализована автоматическая загрузка отсутствующих моделей.
- Добавлено управление параллельностью обработки задач через семафор.
- Разработан тестовый скрипт с генерацией HTML-отчета.
- Обновлены зависимости, добавлен `opencv-contrib-python`.
- Улучшена детализация логов на всех этапах.

### Версия 1.0 - 30-04-2025

- Синхронная обработка (с использованием `threading`).
- Монолитная структура логики компьютерного зрения.
- Базовый детектор лиц Haar Cascade.
- Ограниченный набор проверок с жестко заданными параметрами.
- Текстовый отчет в тестовом скрипте.

## Автор

Maxim Borzov

## Лицензия

MIT